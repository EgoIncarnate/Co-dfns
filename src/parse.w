\def\title{CO-DFNS PARSER (Version 0.1)}
\def\topofcontents{\null\vfill
  \centerline{\titlefont Co-Dfns Parser}
  \vskip 15pt
  \centerline{(Version 0.1)}
  \vfill}
\def\botofcontents{\vfill
\noindent
Copyright $\copyright$ 2013 Aaron W. Hsu $\.{arcfide@@sacrideo.us}$
\smallskip\noindent
All rights reserved.
}

@* Parsing Co-Dfns. The Co-Dfns language is a rather difficult one to 
parse effectively. While most of the language is trivial, the language
has one or two parts that are inherently ambiguous if you do not already
know the variable references are functions or values. This document
describes the parser for Co-Dfns. Most of the parser is designed 
around the PEG grammar given in {\tt grammar.peg}, which is used to 
generate a recursive decent, backtracking parser using the {\tt peg(1)}
program. This file sets the surrounding context for this parser 
and configures its settings so that it is usable in the rest of the 
Co-Dfns ecosystem.

At the moment, we compile a |main()| program for doing program 
recognition. It runs the parser on the file given in the command
line until no more content is parsable, and then exits.

@p
#include <stdio.h>
#include <stdlib.h>

#include "grammar.c"

void
print_usage_exit(char *progname)
{
	printf("%s : [filename]\n", progname);
	exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
	yycontext ctx;
	FILE *infile;
	
	memset(&ctx, 0, sizeof(yycontext));
	
	switch(argc) {
	case 1: 
		ctx.infile = stdin; 
		break;
	case 2:
		if ((infile = fopen(argv[1], "r")) == NULL) {
			perror(argv[0]);
			exit(EXIT_FAILURE);
		}
		ctx.infile = infile;
		break;
	default:
		print_usage_exit(argv[0]);
	}
	
	while(parse_apl(&ctx));
	
	if (argc == 2 && fclose(infile) == EOF) {
		perror(argv[0]);
		exit(EXIT_FAILURE);
	}
	
	return EXIT_SUCCESS;
}

@ The parser generated by {\tt peg} needs to have a few things customized 
to make things nicer to program with. These settings are made here. In 
particular, the main parser name should be |parse_apl| rather than 
|yyparse| and the parser should use a local context. Two additional 
member fields of the parser context will need to be created. The first 
is the environment which will be used to store variable binding classes.
The second is the structure that we use to construct the AST.

@d YYPARSE parse_apl
@d YY_CTX_LOCAL
@d YY_CTX_MEMBERS void *env; void *codestack; FILE *infile;

@ The default parser uses |YY_INPUT(buf, result, max_size)| to read
input in, but this reads from standard input by default, and we would
like to control the input form of the compiler. To do this, we redefine 
this macro to read from the |ctx->infile| which is a member that we 
set to be the input |FILE *| pointer.

@d YY_INPUT(buf, result, max_size)
{
	int yyc = fgetc(ctx->infile);
	result = (EOF == yyc) ? 0 : (*(buf) = yyc, 1);
}

@* Index.
