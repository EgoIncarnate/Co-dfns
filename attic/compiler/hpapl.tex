\input ConTeXtLPMacros

\definefontsynonym[APL][Apl385]
\setupbodyfont[xits]
\definefont[tt][APL sa 1]

\setuppapersize[letter][letter]
\setupwhitespace[medium]

\starttext
\startfrontmatter
\title{HPAPL: The Compiler}

\completecontent
\vfill
Copyright $\copyright$ 2012 Aaron W. Hsu $⟨${\tt arcfide@sacrideo.us}$⟩$

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
\stopfrontmatter

\startbodymatter
\chapter{Introduction}

This is a first simple attempt to get a small piece of each element of 
the HPAPL compiler working and running.

\defchunk{HPAPL Namespace}
:Namespace HPAPL
  ⎕IO ⎕ML←0 0
  /BTEX\chunk{Parsing Utilities}/ETEX
  /BTEX\chunk{File Utilities}/ETEX
  /BTEX\chunk{AST Utilities}/ETEX
  /BTEX\chunk{HPAPL Code}/ETEX
  ∇ Reload;N
    'HPAPL Namespace' #.ConTeXtLP.Tangle './hpapl.tex' './hpapl.dyalog'
    N←#.⎕SE.SALT.Load './hpapl -Target=#'
    ⎕←'Loaded: ',⍕N
  ∇
  Compile←{
    toks←Tokenize ⍺
    ast rest←0 ParseStmts toks
    ast
    ast←FlattenExps ast
    ast←FindFreeVars ast
    ast←ExpandNumberStar ast
    ⍵ OutputC ast
  }
:EndNamespace
\stopchunk

\chapter{Some Basic Utilities}

Throughout the code we use a few utilities that make our life easier. 
We will describe them all here up front before we delve into the meat.
Firstly, we have a set of functions that help us with parsing.  
You might call these parser combinators.  We produce a syntax tree that 
is a linearization of a tree into a matrix of shape $N 3$ where $N$ is 
the number of nodes and 3 is the number of columns.  Column 1 is the 
depth of that node, column 2 the name or type of the node, and 
column 3 is any data that is stored in that field, in the form of a 
vector of fields.

\defchunk{Parsing Utilities}
ParseErr←{(⊂⍬),⊂⍵}
ParseTok←{⍵⍵=⊃⊃⍵: (⊂1 3⍴⍺,(⊂⍺⍺),⊂1⊃⊃⍵),⊂1↓⍵ ⋄ ParseErr ⍵}
ParseSeq←{
  n1 r1←⍺ ⍺⍺ ⍵
  n1≡⍬: ParseErr ⍵
  n2 r2←⍺ ⍵⍵ r1
  n2≡⍬: ParseErr ⍵
  (⊂n1⍪n2),⊂r2
}
ParseChoice←{
  n r←⍺ ⍺⍺ ⍵
  n≡⍬: ⍺ ⍵⍵ ⍵
  n r
}
ParseStar←{
  0=⍴⍵: (⊂0 3⍴⍬),⊂⍵
  ast rst←⍺ ⍺⍺ ⍵
  ast≡⍬: (⊂0 3⍴⍬),⊂⍵
  nxt nst←⍺ (⍺⍺ ParseStar) rst
  (⊂ast⍪nxt),⊂nst
}
\stopchunk

Next, we want to be able to work with files easily, so we have a few 
utilities for printing, writing, and so forth.

\defchunk{File Utilities}
OpenFile←{
  22:: ⍵ ⎕NCREATE 0
  tie←⍵ ⎕NTIE 0
  _←⍵ ⎕NERASE tie
  ⍵ ⎕NCREATE 0
}
∇ TIE println DATA
  TIE print DATA
  (⎕UCS 10)⎕NAPPEND TIE,80
∇
print←{(⎕UCS 'UTF-8' ⎕UCS ⍵)⎕NAPPEND ⍺,80}
\stopchunk

And then we have some utilities that we use when we want to work with 
the AST.

\defchunk{AST Utilities}
Children←{
  c←⊃⍵ ⋄ d←0⌷[1]⍵
  ((0,~∨\c=1↓d)∧(1+c)=d)⊂[0]⍵}
\stopchunk

\chapter{Parsing HPAPL Syntax}

This chapter focuses on getting the HPAPL program from strings into 
a reasonable representation, and getting back into a string again. 

Let's start with a tokenizer.

\startformula
\hbox{\bf Insert missing tokens list here.}
\stopformula

\defchunk{HPAPL Code}
TokPats←'[0-9]+' '[a-zA-Z][a-zA-Z0-9]*' '←' '⎕[a-zA-Z]+' '⎕' '\(' '\)' '⌷' '⍴|⍳|\+|-|×|÷'
TokTypes←'Number' 'Variable' 'Assignment' 'System' 'Quad' 'LeftParen' 'RightParen' 'Index' 'Primitive'
Tokenize←{
  MakeTok←{⍵.PatternNum,⊂⍵.Block[(⊃⍵.Offsets)+⍳⊃⍵.Lengths]}
  (⎕NUNTIE tie)⊢(TokPats⎕S MakeTok) tie←⍵ ⎕NTIE 0
}
\stopchunk

Now let's move to parsing. Here 
is the grammar of our language:\index{Language Grammar}

\define[1]\term{\hbox{\tt #1}}

\startformula
\eqalign{
  Statements  &\Rightarrow Assignment*\cr
  Assignment  &\Rightarrow PrintAssign\ |\ VarAssign\ |\ SelAssgn\cr
  PrintAssign &\Rightarrow \term{⎕}\term{←}\ Variable\cr
  VarAssign   &\Rightarrow Variable\ \term{←}\ Expression\cr
  SelAssgn    &\Rightarrow \term{(}Number\term{⎕}Variable\term{)}
               \term{←}\ Number\cr
  Expression  &\Rightarrow Variable\ |\ Number*\ |\ Application\ |\ NestedExp\cr
  NestedExp   &\Rightarrow \term{(}Expression\term{)}\cr
  Application &\Rightarrow Monadic\ |\ Dyadic\cr
  Dyadic      &\Rightarrow VarOrNumOrNest\ SysOrPrim\ Expression\cr
  Monadic     &\Rightarrow SysOrPrim\ Expression\cr
  VarOrNumOrNest &\Rigtharrow Variable\ |\ Number*\ |\ NestedExp\cr
  SysOrPrim   &\Rightarrow SysVar\ |\ Primitive\cr
  Variable    &\Rightarrow \term{variable}\cr
  Number      &\Rightarrow \term{number}\cr
}
\stopformula

We can translate the above syntax tree into a set of parsers using 
parser combinators pretty easily.  The goal here is to ensure an LL(1) 
grammar so this task will always be easy.  Here is the encoding 
using out parsing combinators.

\defchunk{HPAPL Code}
ParseNum←('Number' ParseTok 0)
ParseVar←('Variable' ParseTok 1)
ParseAssgnTok←('AssignTok' ParseTok 2)
ParseSysTok←('System' ParseTok 3)
ParseQuadTok←('Quad' ParseTok 4)
ParseLeftParenTok←('RightParen' ParseTok 5)
ParseRightParenTok←('LeftParen' ParseTok 6)
ParseIndexTok←('Index' ParseTok 7)
ParsePrimTok←('Primitive' ParseTok 8)
ParseSysOrPrim←(ParseSysTok ParseChoice ParsePrimTok)
ParseNumStar←{
  ast rst←⍺ (ParseNum ParseSeq (ParseNum ParseStar)) ⍵
  ast≡⍬: ParseErr ⍵
  (⊂⍺,(⊂'Number*'),⊂2⌷[1]ast),⊂rst
}
ParseMonadic←{
  n r←(1+⍺)(ParseSysOrPrim ParseSeq ParseExp)⍵
  n≡⍬: ParseErr ⍵
  (⊂(⍺,(⊂'Monadic'),⊂⍬)⍪n),⊂r
}
ParseDyadic←{
  n r←(1+⍺)(ParseNumOrVarOrNest ParseSeq ParseSysOrPrim ParseSeq ParseExp)⍵
  n≡⍬: ParseErr ⍵
  (⊂(⍺,(⊂'Dyadic'),⊂⍬)⍪n),⊂r
}
ParseApplication←(ParseMonadic ParseChoice ParseDyadic)
ParseNestExp←{⍺ (ParseExp ParseParens) ⍵}
ParseNumOrVarOrNest←(ParseVar ParseChoice ParseNumStar ParseChoice ParseNestExp)
ParseExp←(ParseApplication ParseChoice ParseNestExp ParseChoice ParseNumStar ParseChoice ParseVar)
ParseSelLhs←{
  n r←⍺ (ParseNum ParseSeq ParseIndexTok ParseSeq ParseVar) ⍵
  n≡⍬: ParseErr ⍵
  (⊂n[0 2;]),⊂r
}
ParseAssgnRhs←{
  n r←⍺ (ParseAssgnTok ParseSeq ParseExp) ⍵
  n≡⍬: ParseErr ⍵
  (⊂n[1+⍳¯1+⊃⍴n;]),⊂r
}
ParseVarAssgn←{
  n r←(1+⍺)(ParseVar ParseSeq ParseAssgnRhs) ⍵
  n≡⍬: ParseErr ⍵
  (⊂(⍺,(⊂'VarAssign'),⊂⍬)⍪n),⊂r
}
ParsePrintAssgnRhs←{
  n r←⍺ (ParseAssgnTok ParseSeq ParseVar) ⍵
  n≡⍬: ParseErr ⍵
  (⊂1⌷n),⊂r
}
ParsePrintAssgn←{
  n r←(1+⍺)(ParseQuadTok ParseSeq ParsePrintAssgnRhs) ⍵
  n≡⍬: ParseErr ⍵
  (⊂(⍺,(⊂'PrintAssign'),⊂⍬)⍪n[1+⍳¯1+⊃⍴n;]),⊂r
}
ParseParens←{
  n r←(1+⍺)(ParseLeftParenTok ParseSeq ⍺⍺ ParseSeq ParseRightParenTok) ⍵
  n≡⍬: ParseErr ⍵
  (⊂(⍺,(⊂'Nested'),⊂⍬)⍪n[1+⍳¯2+⊃⍴n;]),⊂r
}
ParseSelAssgnRhs←{
  n r←⍺ (ParseAssgnTok ParseSeq ParseNum) ⍵
  n≡⍬: ParseErr ⍵
  (⊂1⌷n),⊂r
}
ParseSelAssgn←{
  n r←(1+⍺)(ParseSelLhs ParseParens ParseSeq ParseSelAssgnRhs) ⍵
  n≡⍬: ParseErr ⍵
  (⊂(⍺,(⊂'SelAssign'),⊂⍬)⍪n),⊂r
}
ParseAssgn←(ParseVarAssgn ParseChoice ParsePrintAssgn ParseChoice ParseSelAssgn)
ParseStmts←{
  ast rst←(1+⍺)(ParseAssgn ParseStar) ⍵
  ast≡⍬: ⎕SIGNAL 2
  (⊂(⍺,(⊂'Statements'),⊂⍬)⍪ast),⊂rst
}
\stopchunk

\chapter{Compiler Passes}

The following passes all expect to have a flat representation of 
function application, without nesting.  This means that we need to 
flatten out the nested representation that we get from the parser.

\defchunk{HPAPL Code}
FlattenExps←{
  (0⌷⍵)⍪⊃⍪/{'VarAssign'≡⊃0 1⌷⍵: FlattenAssgnExp ⍵ ⋄ ⍵}¨Children ⍵
}
FlattenAssgnExp←{
  var exp←Children ⍵
  'Variable'≡⊃0 1⌷exp: ⍵
  'Number*'≡⊃0 1⌷exp: ⍵
  others←(0 2⌷var)FlattenExp exp
  others⍪(0⌷⍵)⍪var⍪(0 2⌷var)MaybeVariable exp
}
MaybeVariable←{
  'Monadic'≡⊃0 1⌷⍵: ⍺ MaybeVarMon ⍵
  'Dyadic'≡⊃0 1⌷⍵: ⍺ MaybeVarDya ⍵
}
MaybeVarMon←{
  fn exp←Children ⍵
  'Variable'≡⊃0 1⌷exp: ⍵
  (0⌷⍵)⍪fn⍪1 3⍴(⊃exp),(⊂'Variable'),⍺
}
MaybeVarDya←{
  lft fn exp←Children ⍵
  'Variable'≡⊃0 1⌷exp: ⍵
  (0⌷⍵)⍪lft⍪fn⍪1 3⍴(⊃exp),(⊂'Variable'),⍺
}
FlattenExp←{
  head←1 3⍴(¯1+⊃⍵),(⊂'VarAssign'),⊂⍬
  head⍪←1 3⍴(⊃⍵),(⊂'Variable'),⍺
  'Monadic'≡⊃0 1⌷⍵: head FlattenExpSub ⊃1⌷Children ⍵
  'Dyadic'≡⊃0 1⌷⍵: head FlattenExpSub ⊃2⌷Children ⍵
}
FlattenExpSub←{
  'Variable'≡⊃0 1⌷⍵: 0 3⍴⍬
  deps←⊣/⍵
  deps←deps-(⊃deps)-1+⊃⍺
  FlattenAssgnExp ⍺⍪deps,1↓[1]⍵
}
\stopchunk


We need to know about the free variables that occur inside of a program 
body.  To do this, we consider only the values that have been assigned.
We store this information as the field data of the top-level 
\term{Program} node.

\defchunk{HPAPL Code}
FindFreeVars←{
  vars←∪(¯1⌽(1⌷[1]⍵)∊⊂'VarAssign')/2⌷[1]⍵
  res←⍵
  (0 2⌷res)←⊂vars
  res
}
\stopchunk

This compiler pass removes the occurrences of numbered array literals 
by converting them into the necessary selective assignments and 
allocations.

\defchunk{HPAPL Code}
ExpandNumberStar←{(0⌷⍵)⍪⊃⍪/ExpandNumStarAssgn¨Children ⍵}
ExpandNumStarAssgn←{
  IsNumStarAssgn ⍵: (MakeNumStarAlloc ⍵)⍪MakeNumStarAssgns ⍵
  ⍵
}
IsNumStarAssgn←{
  'VarAssign'≡⊃0 1⌷⍵: 'Number*'≡⊃0 1⌷⊃1⌷Children ⍵
  0
}
MakeNumStarAlloc←{
  res←2↑⍵
  res⍪←2 3⍴(1+⊃⍵) 'Monadic' ⍬ (2+⊃⍵) 'System' '⎕ALLOC'
  res⍪1 3⍴(2+⊃⍵) 'Number' (⍕⍴⊃2 2⌷⍵) 
}
SelAssgnTempl←0 'SelAssign' ⍬ 1 'Nested' ⍬ 2 'Number' '0'
SelAssgnTempl,←2 'Variable' 'X' 1 'Number' '0'
SelAssgnTempl←5 3⍴SelAssgnTempl  
MakeNumStarAssgns←{
  nums←⊃2 2⌷⍵
  res←((5×⍴nums),3)⍴SelAssgnTempl
  res[4+5×⍳⍴nums;2]←nums
  res[3+5×⍳⍴nums;2]←1 2⌷⍵
  res[2+5×⍳⍴nums;2]←⍕¨⍳⍴nums
  res[;0]+←⊃⍵
  res
}
\stopchunk


\chapter{Outputting C Code}

Let's take our basic syntax tree and print out a C version of the 
program.

\startformula
\eqalign{
  Statements  &\Rightarrow Assignment*\cr
  Assignment  &\Rightarrow PrintAssign\ |\ VarAssign\ |\ SelAssgn\cr
  PrintAssign &\Rightarrow \term{⎕}\term{←}\ Variable\cr
  VarAssign   &\Rightarrow Variable\ \term{←}\ Expression\cr
  SelAssgn    &\Rightarrow \term{(}Number\term{⎕}Variable\term{)}
               \term{←}\ Number\cr
  Expression  &\Rightarrow Variable\ |\ Application\cr
  Application &\Rightarrow Monadic\ |\ Dyadic\cr
  Dyadic      &\Rightarrow NumOrVar SysOrPrim NumOrVar\cr
  Monadic     &\Rightarrow SysOrPrim NumOrVar\cr
  SysOrPrim   &\Rightarrow SysVar\ |\ Primitive\cr
  NumOrVar    &\Rightarrow Number\ |\ Variable\cr 
  Variable    &\Rightarrow \term{variable}\cr
  Number      &\Rightarrow \term{number}\cr
}
\stopformula

\defchunk{HPAPL Code}
∇ fn OutputC ast;tie
  tie←OpenFile fn
  tie println '#include <stdio.h>'
  tie println '#include <stdlib.h>'
  tie println ''
  tie println 'int main(int argc, char *argv[])'
  tie println '{'
  tie OutputCFreeVars ast
  tie OutputCStmts ast
  tie println 'return 0;'
  tie println '}'
  ⎕NUNTIE tie
∇

∇ tie OutputCFreeVars ast
  tie print 'Array '
  vars←⊃0 2⌷ast
  tie print ⊃{⍺,',',⍵}/vars
  tie println ';'
  :For v :In vars
    tie println 'apl_arrayinit(&',v,');'
  :EndFor
∇

OutputCStmts←{⍺∘OutputCAssgn¨Children ⍵}
OutputCAssgn←{
  type←⊃1⌷0⌷⍵
  type≡'VarAssign': ⍺ OutputCVarAssgn ⍵
  type≡'PrintAssign': ⍺ OutputCPrintAssgn ⍵
  type≡'SelAssign': ⍺ OutputCSelAssgn ⍵
}
OutputCVarAssgn←{
  var exp←Children ⍵
  exptype←⊃0 1⌷exp
  'Variable'≡exptype: ⍺ OutputCVarVarAssgn var exp
  'Monadic'≡exptype: ⍺ OutputCVarMonAssgn var exp
  'Dyadic'≡exptype: ⍺ OutputCVarDyaAssgn var exp
}

∇ tie OutputCVarVarAssgn(v1 v2)
  tie print 'apl_varassign('
  tie OutputCVar v1
  tie print ','
  tie OutputCVar v2
  tie println ');'
∇

SysNamesMon←'⎕ALLOC' (1⍴'⍳')
SysCNamesMon←'apl_alloc' 'apl_iotam'
∇ tie OutputCVarMonAssgn(v1 app);fncn
  fn vl←Children app
  fncn←⊃(SysNamesMon⍳0 2⌷fn)⌷SysCNamesMon
  tie print fncn
  tie print '('
  tie OutputCVar v1
  tie print ','
  tie OutputCVar vl
  tie println ');'
∇

SysNamesDya←1⍴⊂1⍴'+'
SysCNamesDya←1⍴⊂'apl_add'
∇ tie OutputCVarDyaAssgn(v1 app)
  lft fn rgt←Children app
  fncn←⊃(SysNamesDya⍳0 2⌷fn)⌷SysCNamesDya
  tie print fncn
  tie print '('
  tie OutputCVar v1
  tie print ','
  tie OutputCVar lft
  tie print ','
  tie OutputCVar rgt
  tie println ');'
∇

∇ tie OutputCSelAssgn ast;tgt;exp;idx;var
  tgt exp←Children ast
  idx var←Children tgt
  tie print 'apl_selassign('
  tie OutputCVar var
  tie print ','
  tie OutputCNum idx
  tie print ','
  tie OutputCNum exp
  tie println ');'
∇

∇ tie OutputCPrintAssgn ast;exp
  exp←⊃Children ast
  tie print 'apl_print('
  tie OutputCVar exp
  tie println ');'
∇
OutputCNum←{⍺ print ⊃0 2⌷⍵}
OutputCVar←{⍺ print ⊃0 2⌷⍵}
\stopchunk

\chapter{HPAPL Runtime}

We need to provide some level of runtime support for the code that we 
compile.  More particularly, these are the things that we link against 
when building the generated C code. We have the following structure.
To start with, we need a geneal abstraction for arrays, which goes in 
a separate header file.

\defchunk{HPAPL Runtime Header}
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct apl_array_t {
  size_t        rank;
  unsigned int  *shape;
  size_t        length;
  int64_t       *elems;
} ArrayStruct;
typedef *ArrayStruct Array;
\stopchunk

We also implement some basic functions for allocating arrays.

\defchunk{HPAPL Runtime Code}
#include "hpapl.h"

void
apl_arrayinit(Array *a)
{
        int *tshp;
        Array tmp;
        
        tmp = malloc(sizeof(struct apl_array_t));
        if (NULL == tmp) {
                perror("init failure");
                exit(1);
        }
        
        tshp = malloc(sizeof(int));
        if (NULL == tshp) {
                perror("init failure");
                exit(1);
        }
        
        tmp->rank = 1;
        tshp[0] = 0;
        tmp->shape = tshp;
        tmp->length = 0;
        tmp->elems = NULL;
        *a = tmp;
}

void
apl_alloc(Array a, size_t len)
{
        int64_t *tmp;
        tmp = realloc(a->elems, len);
        if (NULL == tmp) {
                perror("allocation failure");
                exit(1);
        }
        a->length = len;
        a->elems = tmp;
}
\stopchunk

Now we can implement the rest of our runtime.

\defchunk{HPAPL Runtime Code}
void
apl_selassign(Array x, size_t i, int64_t v)
{
        x->elems[i] = v;
}

void
apl_iotam(Array a, Array b)
{
        unsigned int i;
        size_t tl;
        int64_t n, *t;
        
        tl = a->length;
        t = a->elems;
        n = b->elems[0];
        
        if (tl < n) t = realloc(t, n*sizeof(int64_t));
        if (NULL == t) {
                perror("iota alloc error");
                exit(1);
        }
        
        a->elems = t;
        a->length = tl > n ? tl : n;
        a->shape[0] = n;
        
        for (i = 0; i < n; i++) *(t++) = i;
}
\stopchunk

We also define something for printing.

\defchunk{HPAPL Runtime Code}
void
apl_print(Array a)
{
        size_t  i, len;
        int64_t *t;
        
        len = a->length;
        t   = a->elems;
        
        for (i = 0; i < len; i++) 
                printf("%d ", *(t++));
        
        printf("\n");
}
\stopchunk


\stopbodymatter

\startappendices

\stopappendices

\startbackmatter
\completeindex
\stopbackmatter

\stoptext
