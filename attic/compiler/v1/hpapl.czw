\font\rm = "XITS" at 10pt
\font\tt = "APL385 Unicode" at 10pt
\font\bf = "XITS/B" at 10pt
\font\it = "XITS/I" at 10pt
\font\titlefont = "XITS" at 17pt

\def\title{HPAPL (VERSION 0.1)}
\def\topofcontents{\null\vfill
  \centerline{\titlefont HPAPL Compiler}
  \vskip 15pt
  \centerline{(Version 0.1)}
  \vfill}
\def\botofcontents{\vfill
\noindent
Copyright $\copyright$ 2012 Aaron W. Hsu {\tt <arcfide@@sacrideo.us>}
\smallskip\noindent
Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
\smallskip\noindent
THE SOFTWARE IS PROVIDED “AS IS” AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
}

@* Introduction. This is the first prototype of the HPAPL compiler.  
HPAPL stands for ``High performance $\{$A,Axiomatic$\}$ 
$\{$Parallel,Programming$\}$ Language.'' This first draft is designed to 
allow me to quickly prototype and test the core of the language.

The compiler is layed out in the following main sections:

@p
;@<Define program AST constructor and modules@>
@<Helper Utilities@>
@<Syntax AST Definitions@>
@<AST Pretty Printer@>
@<Core code renderer@>
;@<Rewriting system@>
;@<Default rewrite rules@>

@* Syntax. The way HPAPL works is a little strange, as there is no 
parser.  Instead, users are expected to use a structured editor to 
directly construct an AST.  There is a way to serialize and to pretty 
print the AST.  Here is a basic outline of the AST structure:

$$\eqalign{
  Essay       &:= Title_{str}\ (Code \mid Prose)*\cr
  Prose       &:= \hbox{string}\cr
  Code        &:= Section \mid Function \mid Program\cr
  Section     &:= Name_{str}\ Body_{blk\mid{}exp}\cr
  Function    &:= Name_{var} Return_{var}\ Left_{var}\ Right_{var}\ 
                  Local_{var}*\ Body_{blk}\cr
  Program     &:= Body_{blk}\cr
  Block       &:= Statement*\cr
  Statement   &:= Assignment \mid If \mid While\cr
  If          &:= Test_{exp}\ Consequent_{blk}\ Alternative_{blk}\cr
  While       &:= Test_{exp}\ Body_{blk}\cr
  Assignment  &:= Target_{var}\ Value_{exp}\cr
  Expression  &:= Array \mid Application \mid Reference_{var}\cr
  Array       &:= NumArray \mid CharArray \mid MixArray\cr
  NumArray    &:= \hbox{number}*\cr
  CharArray   &:= \hbox{character}*\cr
  MixArray    &:= (\hbox{number} \mid \hbox{character})*\cr
  Application &:= Niladic \mid Monadic \mid Dyadic\cr
  Niladic     &:= Name_{var}\cr
  Monadic     &:= Name_{var}\ Right_{exp}\cr
  Dyadic      &:= Name_{var}\ Left_{exp}\ Right_{exp}\cr
  Variable    &:= \hbox{restricted string}\cr
}$$

\noindent Each of these productions corresponds to a type of node in 
our syntax tree.  For each of these nodes, we will have the main 
procedural data type, but we will also define a syntactic construct that
allows one to construct the AST as if it were an S-expression.

@ We will proceed from the bottom up to define each of 
these, starting with what a variable is. In particular, we use the 
term variable to represent any reference to some sort of slot, including 
our primitive forms. This means that we allow arbitrary strings in the 
variables. 

@c () => (<variable> make-variable variable? variable-string)
@<Syntax AST Definitions@>=
(define-record-type (<variable> make-variable variable?)
  (fields (immutable string variable-string))
  (protocol
    (lambda (n)
      (lambda (str)
        (unless (string? str)
          (error #f "invalid variable name" str))
        (n str)))))

@ The syntax of the |Variable| form should take a single string or 
symbol.

@c () => (variable)
@<Syntax AST Definitions@>=
(define-syntax variable
  (syntax-rules ()
    [(_ sym) (symbol? (syntax->datum #'sym))
     (make-variable (symbol->string 'sym))]
    [(_ str)
     (make-variable 'str)]))

@ User variables are the class of variables normally allowed in a Scheme
program. In our case, we allow only alphanumeric characters in user
variable names, except for the |∆| character.

@c () => (<user-variable> make-user-variable user-variable?)
@<Syntax AST Definitions@>=
(define (valid-variable? str)
  (for-all (lambda (c) (or (char-alphanumeric? c) (char=? #\∆ c)))
           (string->list str)))
(define-record-type (<user-variable> make-user-variable user-variable?)
  (parent <variable>)
  (protocol
    (lambda (p)
      (lambda (str) 
        (unless (valid-variable? str)
          (error #f "invalid user variable" str))
        ((p str))))))

@ @c () => (char-alphanumeric?)
@<Helper Utilities@>=
(define (char-alphanumeric? c)
  (or (char-alphabetic? c) (char-numeric? c)))

@ The |user-variable| syntax is the same as |variable| with a different 
constructor.

@c () => (user-variable)
@<Syntax AST Definitions@>=
(define-syntax user-variable
  (syntax-rules ()
    [(_ sym) (symbol? (syntax->datum #'sym))
     (make-user-variable (symbol->string 'sym))]
    [(_ str)
     (make-user-variable 'str)]))
     
@ We would like to be able to compare variables.

@c () => (variable=?)
@<Syntax AST Definitions@>=
(define (variable=? v1 v2)
  (string=? (variable-string v1) (variable-string v2)))

@ The next few productions, $Array$ and $Application$ are a part of 
the $Expression$ production, so we will just go quickly here to define 
a parent |<expression>| type for both.  There is a constructor syntax
for expressions but to understand how they work, let's just go through 
the two cases first before defining the expression syntax.

@c () => (<expression> expression?)
@<Syntax AST Definitions@>=
(define-record-type (<expression> make-expression expression?))

@ Let's take care of the $Reference$ production. This is just a 
container for a variable.

@c () => (<reference> reference? reference-variable reference)
@<Syntax AST Definitions@>=>
(define-record-type (<reference> make-reference reference?)
  (parent <expression>)
  (fields (immutable variable reference-variable))
  (protocol
    (lambda (p)
      (lambda (var)
        (unless (variable? var) 
          (error #f "invalid reference" var))
        ((p) var)))))
(define-syntax reference
  (syntax-rules ()
    [(_ var) (make-reference (variable var))]))

@ Next we will take on the $Array$ production.  In this case, we have 
three subarrays:

$$\eqalign{
  Array       &:= NumArray \mid CharArray \mid MixArray\cr
  NumArray    &:= \hbox{number}*\cr
  CharArray   &:= \hbox{character}*\cr
  MixArray    &:= (\hbox{number} \mid \hbox{character})*\cr
}$$

\noindent In each of the child cases, only the contents of the list 
are different.  This means that we will define the field in the 
$Array$ type, and just twiddle with the protocol in the children.
We will define the syntax for arrays after we have designed the 
child constructors.

@c () => (make-array array? <array> array-elements)
@<Syntax AST Definitions@>=
(define-record-type (<array> make-array array?)
  (parent <expression>)
  (fields (immutable elements array-elements))
  (protocol
    (lambda (p)
      (lambda (lst)
        (unless (list? lst)
          (error #f "invalid set of array elements" lst))
        ((p) lst)))))

@ The first and easiest $Array$ child is the $NumArray$ production. 
This will accept either flonums or fixnums as valid numbers.

@c () => (num-array? make-num-array <num-array>)
@<Syntax AST Definitions@>=
(define (valid-num-array? lst)
  (for-all (lambda (e) (or (fixnum? e) (flonum? e))) lst))
(define-record-type (<num-array> make-num-array num-array?)
  (parent <array>)
  (protocol
    (lambda (p)
      (lambda (lst)
        (unless (valid-num-array? lst)
          (error #f "invalid number array" lst))
        ((p lst))))))

@ The character array type is a bit more complex, because we want to 
accept either a string or a list of characters as valid input. 

@c () => (<char-array> char-array? make-char-array)
@<Syntax AST Definitions@>=
(define (valid-char-array? lst-or-str)
  (or (string? lst-or-str)
      (and (list? lst-or-str)
           (for-all char? lst-or-str))))
(define-record-type (<char-array> make-char-array char-array?)
  (parent <array>)
  (protocol
    (lambda (p)
      (define (normalize lst-or-str)
        (if (string? lst-or-str)
            (string->list lst-or-str)
            lst-or-str))
      (lambda (lst-or-str)
        (unless (valid-char-array? lst-or-str)
          (error #f "invalid character array" lst-or-str))
        ((p (normalize lst-or-str)))))))
        
@ For a mixed array, we want to accept a list of character, fixnums,
flonums, or strings, and any combination of those.  We will normalize 
things out so that the strings are just spliced in as lists of characters.
This assures us that we still avoid nested arrays in our implementation
of HPAPL at the moment.

@c () => (<mixed-array> make-mixed-array mixed-array?)
@<Syntax AST Definitions@>=
(define (valid-mixed-array? lst)
  (for-all 
    (lambda (e) (or (fixnum? e) (flonum? e) (char? e) (string? e)))
    lst))
(define-record-type (<mixed-array> make-mixed-array mixed-array?)
  (parent <array>)
  (protocol
    (lambda (p)
      (define (normalize lst)
        (fold-right
          (lambda (e s)
            (if (string? e)
                (append (string->list e) s)
                (cons e s)))
          '() lst))
      (lambda (lst)
        (unless (valid-mixed-array? lst)
          (error #f "invalid mixed array" lst))
        ((p (normalize lst)))))))
        
@ We now have constructor for each of the child types of the $Array$ 
production.  However, it is inconvenient to have to use these 
constructors instead of just saying, ``Give me a new array, figure out 
the sub-type for me.''  To make this possible, and because this is 
the only use case that seems desirable, we define a single |array| 
syntax for constructing arrays of any subtype.

@c () => (array)
@<Syntax AST Definitions@>=
(define (array-type lst)
  (define (loop lst type)
    (cond
      [(null? lst) type]
      [(or (fixnum? (car lst)) (flonum? (car lst))) 
       (if (or (not type) (eq? 'numeric type))
           (loop (cdr lst) 'numeric)
           'mixed)]
      [(or (char? (car lst)) (string? (car lst)))
       (if (or (not type) (eq? 'character type))
           (loop (cdr lst) 'character)
           'mixed)]
      [else #f]))
  (if (null? lst) 'numeric (loop lst #f)))
(implicit-exports #t)
(define-syntax array
  (syntax-rules ()
    [(_ elem) (string? (syntax->datum #'elem))
     (make-char-array elem)]
    [(_ elem ...)
     (let ([tmp (list 'elem ...)])
       (case (array-type tmp)
         [(numeric) (make-num-array tmp)]
         [(character) (make-char-array tmp)]
         [(mixed) (make-mixed-array tmp)]
         [else (error #f "invalid array" (list 'elem ...))]))]))

@ With the $Array$ type finished, let's define the type for the 
$Application$ production.  An application has the following rules:

$$\eqalign{
  Application &:= Niladic \mid Monadic \mid Dyadic\cr
  Niladic     &:= Name_{var}\cr
  Monadic     &:= Name_{var}\ Right_{exp}\cr
  Dyadic      &:= Name_{var}\ Left_{exp}\ Right_{exp}\cr
}$$

\noindent In these rules, we can tell which of the child application 
types that we have by the count of the fields.  We will define 
the main application type first.

@c () => (<application> make-application application? application-name)
@<Syntax AST Definitions@>=
(define-record-type (<application> make-application application?)
  (parent <expression>)
  (fields (immutable name application-name))
  (protocol
    (lambda (p)
      (lambda (name)
        (unless (variable? name)
          (error #f "invalid application name" name))
        ((p) name)))))

@ The niladic form is just another name for an application.  Since we 
do not see these form nearly as often, we will not define this type 
explicitly, instead, an application is niladic if the following 
predicate holds.

@c () => (niladic?)
@<Syntax AST Definitions@>=
(define (niladic? app)
  (and (application? app) (not (monadic? app)) (not (dyadic? app))))

@ The monadic form has a single argument expression, which is always 
the right argument. This right argument is an expression.

@c () => (<monadic> make-monadic monadic? monadic-right)
@<Syntax AST Definitions@>=
(define-record-type (<monadic> make-monadic monadic?)
  (parent <application>)
  (fields (immutable right monadic-right))
  (protocol
    (lambda (p)
      (lambda (name right)
        (unless (and (variable? name) (expression? right))
          (error #f "invalid monadic application" name right))
        ((p name) right)))))

@ The dyadic form has two argument expressions, a right and a left 
form.

@c () => (<dyadic> make-dyadic dyadic? dyadic-left dyadic-right)
@<Syntax AST Definitions@>=
(define-record-type (<dyadic> make-dyadic dyadic?)
  (parent <application>)
  (fields (immutable left dyadic-left) (immutable right dyadic-right))
  (protocol
    (lambda (p)
      (lambda (name left right)
        (unless (and (variable? name) (expression? left) (expression? right))
          (error #f "invalid dyadic application" name left right))
        ((p name) left right)))))

@ Like the array, we want a general application constructor rather than 
being required to use a different constructor for each individual application 
sub-type.  To this end we define the |application| syntax to have three 
forms corresponding to the three possible application types.

@c () => (application)
@<Syntax AST Definitions@>=
(define-syntax application
  (syntax-rules ()
    [(_ name) (make-application (variable name))]
    [(_ name right) (make-monadic (variable name) right)]
    [(_ left name right) (make-dyadic (variable name) left right)]))

@ Now that the reader has a firm grasp of how the $Array$ and $Application$ 
sub-types of expressions work, we can start to consider what a syntactic 
constructor for expressions should look like.  Specifically, it should 
hideaway the unnecessary detail of wrapping everything in application 
and array forms.  This leads us to a few basic s-expression based 
forms that could appear for an expression:

\medskip\verbatim
<int_char_str> <int_char_str> ...
(<expr>)
<symbol>
<symbol> <expr>
<expr> <symbol> <expr>
!endverbatim\medskip

\noindent The first form represents the three types of arrays, which 
are all flat and which can be dispatched off to the |array| syntactic
constructor.  The other recursive forms represent dyadic and monadic 
application.  We have a choice about how we want to consider the 
single |<symbol>| case.  We could have it represent a niladic application, 
but this is likely to be less useful.  Instead, this represents a 
variable reference. The parenthesized one represents 
the means by which we can specify order of evaluation other than the 
default. Using this s-expression based representation makes it much 
easier to construct the AST.

@c () => (expression)
@<Syntax AST Definitions@>=
(meta define (int-char-str? stx)
  (let ([dat (syntax->datum stx)])
    (or (fixnum? dat) (flonum? dat) 
        (char? dat) (string? dat))))
(define ⟨) (define ⟩)
(trace-define-syntax expression
  (syntax-rules ()
    [(_ ()) (array)]
    [(_ (elem ...)) (expression elem ...)]
    [(_ ics ...) (for-all int-char-str? #'(ics ...)) (array ics ...)]
    [(_ f) (symbol? (syntax->datum #'f)) (reference f)]
    [(_ f r) (symbol? (syntax->datum #'f))
     (application f (expression r))]
    [(_ l f r ...) (symbol? (syntax->datum #'f)) 
     (application (expression l) f (expression r ...))]
    [(_ f r ...) (symbol? (syntax->datum #'f))
     (application f (expression r ...))]
    [(_ ics rest ...) (int-char-str? #'ics) (expression (ics) rest ...)]
    [(_ (ics* ...) ics rest ...) (for-all int-char-str? #'(ics ics* ...))
     (expression (ics* ... ics) rest ...)]))

@ With the $Expression$ production and all of its sub-productions out 
of the way, that leaves the $Statement$ production as the next major 
container type.

@c () => (<statement> make-statement statement?)
@<Syntax AST Definitions@>=
(define-record-type (<statement> make-statement statement?))

@ The simplest possible statement is the assignment statement.

$$Assignment  := Target_{var}\ Value_{exp}$$

\noindent We have already defined the types for $Target$ and $Value$
so we have little more to do.  

@c () => (<assignment> make-assignment assignment?
          assignment-target assignment-value)
@<Syntax AST Definitions@>=
(define-record-type (<assignment> make-assignment assignment?)
  (parent <statement>)
  (fields (immutable target assignment-target) 
          (immutable value assignment-value))
  (protocol
    (lambda (p)
      (lambda (target value)
        (unless (and (variable? target) (expression? value))
          (error #f "invalid assignment" target value))
        ((p) target value)))))

@ Assignment gets its own |assignment| syntax for creating nodes of 
this type. We will also give this a nice short name |←| to map easily 
to the APL syntax.

@c () => (assignment ←)
@<Syntax AST Definitions@>=
(define-syntax assignment
  (syntax-rules ()
    [(_ target expr ...) 
     (make-assignment (variable target) (expression expr ...))]))
(alias ← assignment)

@ The $If$ and $While$ statements both use the $Block$ production, 
which is just a list of $Statement$s.

$$Block       := Statement*$$

\noindent Let's go ahead and define the $Block$ production here to 
make things clear for the $If$ and $While$ productions.

@c () => (<block> make-block block? block-statements)
@<Syntax AST Definitions@>=
(define-record-type (<block> make-block block?)
  (fields (immutable statements block-statements))
  (protocol
    (lambda (n)
      (lambda (stmts)
        (unless (for-all statement? stmts)
          (error #f "invalid statement block" stmts))
        (n stmts)))))

@ To make creating blocks easier, we have the following |block| syntax
which does not exactly mirror the signature of the |make-block| 
procedure.

@c () => (block)
@<Syntax AST Definitions@>=
(define-syntax block
  (syntax-rules ()
    [(_ stmt ...) (make-block (list stmt ...))]))

@ With $Block$ now clearly defined, let's revisit the $If$ production.

$$If  := Test_{exp}\ Consequent_{blk}\ Alternative_{blk}$$

\noindent It should be noted that we represent a one armed if with a 
alternative field that is |(block)|. 

@c () => (<if> make-if if? if-test if-consequent if-alternative)
@<Syntax AST Definitions@>=
(define-record-type (<if> make-if if?)
  (parent <statement>)
  (fields (immutable test if-test) 
          (immutable consequent if-consequent) 
          (immutable alternative if-alternative))
  (protocol
    (lambda (p)
      (lambda (test consequent alternative)
        (unless (and (expression? test) 
                     (block? consequent) (block? alternative))
          (error #f "invalid if statement" test consequent alternative))))))

@ We define |:If| as our syntax for |make-if|. 

@c () => (:If)
@<Syntax AST Definitions@>=
(define-syntax :If
  (syntax-rules ()
    [(_ test consequent) (make-if test consequent (block))]
    [(_ test consequent alternative)
     (make-if test consequent alternative)]))

@ That leaves only the $While$ production waiting to complete the 
$Statement$ production sub-types.

$$While := Test_{exp} Body_{blk}$$

\noindent This one is straightforward.

@c () => (<while> make-while while? while-test while-body)
@<Syntax AST Definitions@>=
(define-record-type (<while> make-while while?)
  (parent <statement>)
  (fields (immutable test while-test) (immutable body while-body))
  (protocol
    (lambda (p)
      (lambda (test body)
        (unless (and (expression? test) (block? body))
          (error #f "invalid while loop" test body))
        ((p) test body)))))

@ We implicitly wrap the body in a |block| form in our |:While| syntax 
so that we do not have to type it in so many times.

@c () => (:While)
@<Syntax AST Definitions@>=
(define-syntax :While
  (syntax-rules ()
    [(_ test stmts ...) (make-while test (block stmts ...))]))

@ All that is left are the top level syntaxes.  We will handle 
the $Code$ production next.

$$\eqalign{
  Code        &:= Section \mid Function \mid Program\cr
  Section     &:= Name_{str}\ Body_{blk}\cr
  Function    &:= Return_{var}\ Left_{var}\ Right_{var}\ Local_{var}*\ Body_{blk}\cr
  Program     &:= Body_{blk}\cr
}$$

\noindent None of these share any common fields, so we use an empty 
parent type |<code>|.

@c () => (<code> make-code code?)
@<Syntax AST Definitions@>=
(define-record-type (<code> make-code code?))

@ The simplest code sub-type is
$Program$ so we will do that here.  It has only a single code body.

@c () => (<program> make-program program? program-body)
@<Syntax AST Definitions@>=
(define-record-type (<program> make-program program?)
  (parent <code>)
  (fields (immutable body program-body))
  (protocol
    (lambda (p)
      (lambda (body)
        (unless (block? body)
          (error #f "invalid program body" body))
        ((p) body)))))

@ The |:Program| syntax implicitly wraps its given forms in a |block| 
form, so there should be no need to do this explicitly when creating 
|:Program| elements.

@c () => (:Program)
@<Syntax AST Definitions@>=
(define-syntax :Program
  (syntax-rules ()
    [(_ stmt ...) (make-program (block stmt ...))]))

@ Sections are just blocks of code or expressions with names attached 
to them.  Names are just strings.

@c () => (<section> make-section section? section-name section-body)
@<Syntax AST Definitions@>=
(define-record-type (<section> make-section section?)
  (parent <code>)
  (fields (immutable name section-name) (immutable body section-body))
  (protocol
    (lambda (p)
      (lambda (name body)
        (unless (and (string? name) (or (block? body) (expression? body)))
          (error #f "invalid section" name body))
        ((p) name body)))))

@ Our |:Section| syntax is pretty straightforward. We have two versions, 
one for statements and one for holding an expression.

@c () => (:Section :SectionExp)
@<Syntax AST Definitions@>=
(define-syntax :Section
  (syntax-rules ()
    [(_ name body ...) (string? (syntax->datum #'name))
     (make-section name (block body ...))]))
(define-syntax :SectionExp
  (syntax-rules ()
    [(_ name body ...) (string? (syntax->datum #'name))
     (make-section name (expression body ...))]))

@ The $Function$ production is the most complicated form, because 
we need to keep track of the type of function definition. We use |#f|
in either the $Left$, $Right$, or $Return$ fields to indicate an absence 
of variable there. 

@c () => (<function> make-function function?
          function-return function-left function-right function-locals
          function-body function-name)
@<Syntax AST Definitions@>=
(define (valid-function? ret lft nam rgt lcls code)
  (and (or (not ret) (user-variable? ret))
       (or (not lft) (user-variable? lft))
       (user-variable? nam)
       (or (not rgt) (user-variable? rgt))
       (for-all user-variable? lcls)
       (block? code)))
(define-record-type (<function> make-function function?)
  (parent <code>)
  (fields (immutable return function-return) 
          (immutable left function-left)
          (immutable name function-name)
          (immutable right function-right)
          (immutable locals function-locals)
          (immutable body function-body))
  (protocol
    (lambda (p)
      (lambda (r a n b l c)
        (unless (valid-function? r a n b l c)
          (error #f "invalid function definition" r a n b l c))
        ((p) r a n b l c)))))

@ Our syntax for |function| creation allows us to avoid explicitly 
using the |#f| atoms in our written out syntax trees.

$$(function\ ([result \gets]\ [left]\ name\ [right])\ 
  (locals\ \ldots)\ body\ \ldots)$$

\noindent The brackets above indicate an optional form.  In this case 
we implicitly create the variables, assuming that the $result$, $left$, 
and $right$ forms are symbols. We alias |∇| to |function| to make things 
easier to write.  We do not export the |←| identifier here as it is used 
by the assignment function elsewhere, and we export it there instead.

@c () => (function ∇)
@<Syntax AST Definitions@>=
(define %%)
(meta define (symbols? syms)
  (define (char-alphanumeric? x) (or (char-alphabetic? x) (char-numeric? x)))
  (define (valid? x) (for-all char-alphanumeric? (string->list x))) 
  (for-all (lambda (d) (and (symbol? d) (valid? (symbol->string d)))) 
    (map syntax->datum syms)))
(define-syntax function
  (syntax-rules (%% ←)
    [(_ (n) (locals ...) body ...) (symbols? #'(n locals ...))
     (function %% n #f #f #f (locals ...) body ...)]
    [(_ (n b) (locals ...) body ...) (symbols? #'(n b locals ...))
     (function %% #f #f b (locals ...) body ...)]
    [(_ (a n b) (locals ...) body ...) (symbols? #'(a n b locals ...))
     (function %% n #f a b (locals ...) body ...)]
    [(_ (r ← n) (locals ...) body ...) (symbols? #'(r n locals ...))
     (function %% n r #f #f (locals ...) body ...)]
    [(_ (r ← n b) (locals ...) body ...) (symbols? #'(r n b locals ...))
     (function %% n r #f b (locals ...) body ...)]
    [(_ (r ← a n b) (locals ...) body ...) (symbols? #'(r a n b locals ...))
     (function %% n r a b (locals ...) body ...)]
    [(_ %% n r a b (locals ...) body ...)
     (make-function 
       (and 'r (user-variable r))
       (and 'a (user-variable a))
       (user-variable n)
       (and 'b (user-variable b))
       (list (user-variable locals) ...)
       (block body ...))]))
(alias ∇ function)

@ The last remaining element before we get to $Essay$ is the $Prose$ 
type, which is trivial.  We will still use the syntax |prose| to 
enforce a string literal rather than an expression when creating prose 
nodes.

@c () => (<prose> make-prose prose? prose prose-text)
@<Syntax AST Definitions@>=
(define-record-type (<prose> make-prose prose?)
  (fields (immutable text prose-text))
  (protocol
    (lambda (n)
      (lambda (str)
        (unless (string? str)
          (error #f "invalid prose block" str))
        (n str)))))
(define-syntax prose
  (syntax-rules ()
    [(_ str) (string? (syntax->datum #'str)) (make-prose str)]))

@ Our top-level production is the $Essay$ production. This just 
encapsulates a list of $Prose$ and $Code$ objects together with a 
title, which is just a string.

@c () => (<essay> make-essay essay? essay-sections essay-title)
@<Syntax AST Definitions@>=
(define-record-type (<essay> make-essay essay?)
  (fields
    (immutable title essay-title) 
    (immutable sections essay-sections))
  (protocol
    (lambda (n)
      (lambda (title sects)
        (unless (for-all (lambda (e) (or (prose? e) (code? e))) sects)
          (error #f "invalid essay sections" sects))
        (unless (string? title)
          (error #f "invalid essay title" title))
        (n title sects)))))

@ The |:Essay| syntax accepts strings in the prose blocks for convenience
but is otherwise much like the |make-essay| function.

@c () => (:Essay)
@<Syntax AST Definitions@>=
(define-syntax :Essay
  (syntax-rules (%%)
    [(_ %% title (done ...) ()) (make-essay title (list done ...))]
    [(_ %% title (done ...) (e rest ...)) (string? (syntax->datum #'e))
     (:Essay %% title (done ... (prose e)) (rest ...))]
    [(_ %% title (done ...) (e rest ...)) 
     (:Essay %% title (done ... e) (rest ...))]
    [(_ title sects ...) (string? (syntax->datum #'title))
     (:Essay %% title () (sects ...))]))


@* 2 Pretty printing the AST. While the AST makes for a reasonable way 
of constructing programs, it is not nice to look at the output.  We 
want to have a way of pretty printing the AST.  I would almost want 
this to be the serializable version of the code too, but right now 
there is no parser, so we use the default Chez Scheme serialization, 
since we can still read things back in.  We do not have a way of 
reading in a pretty printed piece of code, yet.  We will proceed from 
the top down to create the pretty printer.  Every $Essay$ will be 
printed in this form:

\medskip\verbatim
┌───────┐
│<Title>│
└───────┘

<section>

<section>

...
!endverbatim\medskip

@c () => (pretty-print-ast)
@<AST Pretty Printer@>=
(define (pretty-print-ast ast)
  (assert (essay? ast))
  (let ([title (essay-title ast)])
    (let ([line (make-string (string-length title) #\─)])
      (printf "┌~a┐~n│~a│~n└~a┘~n~n" line title line)))
  (for-each
    (lambda (e)
      (cond
        [(code? e) (pretty-print-code e)]
        [(prose? e)   (pretty-print-prose e)]
        [else (error 'pretty-print-ast "unknown essay section" e)])
      (newline))
    (essay-sections ast)))

@ We need to have some way of controlling the indent level, 
so we will use the |pp-ast-indent| parameter to define the indent
level. We also define a simple procedure to generate the right number 
of indent spaces based on the indent level.

@c () => (pp-ast-indent)
@<AST Pretty Printer@>=
(define pp-ast-indent 
  (make-parameter 0
    (lambda (x)
      (unless (and (number? x) (exact? x) (or (zero? x) (positive? x)))
        (error #f "invalid indent" x))
      x)))
(define (println/indent fmt . args)
  (printf "~a~?~n"
    (make-string (* 2 (pp-ast-indent)) #\space)
    fmt args))
  
@ Next we need to define a pretty printer for prose.  This is actually, 
quite easy, because it it just the prose string with each line indented.

@c () => ()
@<AST Pretty Printer@>=
(define (pretty-print-prose prose)
  (define (line) (get-line (current-input-port)))
  (assert (prose? prose))
  (with-input-from-string (prose-text prose)
    (lambda ()
      (let loop ()
        (let ([line (line)])
          (unless (eof-object? line)
            (println/indent "~a" line)
            (loop)))))))

@ When printing code, we have three different specialized printers 
for the three different cases.

@c () => ()
@<AST Pretty Printer@>=
(define (pretty-print-code code)
  (assert (code? code))
  (cond
    [(section? code) (pretty-print-section code)]
    [(function? code) (pretty-print-function code)]
    [(program? code) (pretty-print-program code)]
    [else (error 'pretty-print-code "unknown code type" code)]))

@ Printing a program is probably the easiest, as it is just a block 
of code with some surrounding elements.

\medskip\verbatim
:Program
  <block>
:EndProgram
!endverbatim\medskip

\noindent We will indent one level when we print the block.

@c () => ()
@<AST Pretty Printer@>=
(define (pretty-print-program prog)
  (assert (program? prog))
  (let ([body (program-body prog)])
    (println/indent ":Program")
    (indented (pretty-print-block body))
    (println/indent ":EndProgram")))

@ In the above code, we use the |indented| form, which is a wrapper 
to make it easier for me to specify a single increased indentation 
level.  We define that here.

@c () => ()
@<AST Pretty Printer@>=
(define-syntax indented
  (syntax-rules ()
    [(_ exp ...) 
     (parameterize ([pp-ast-indent (+ 1 (pp-ast-indent))])
       exp ...)]))

@ The $Section$ type of code is the next easiest to pretty print, as it is 
just a name and a block of code following this pattern:

\medskip\verbatim
⟨<Section name>⟩≡
  <block>
∎
!endverbatim\medskip

@c () => ()
@<AST Pretty Printer@>=
(define (pretty-print-section sect)
  (assert (section? sect))
  (println/indent "⟨~a⟩≡" (section-name sect))
  (indented 
    (if (block? (section-body sect))
        (pretty-print-block (section-body sect))
        (println/indent (expression->string (section-body sect)))))
  (println/indent "∎"))

@ Printing the $Function$s is a little more difficult.  We follow something 
of this pattern:

\medskip\verbatim
∇R←L F R;<local>;...
  <block>
∇
!endverbatim\medskip

\noindent In particular, we only print the return variable and assignment 
arrow if we have a return value, and likewise for the left and right arguments.
We also only print the locals if we have some.

@c () => ()
@<AST Pretty Printer@>=
(define (pretty-print-function funct)
  (define (str get) (cond [(get funct) => variable-string] [else #f]))
  (assert (function? funct))
  (println/indent "∇~@[~a←~]~@[~a ~]~a~@[ ~a~]~{;~a~}"
    (str function-return)
    (str function-left)
    (variable-string (function-name funct))
    (str function-right)
    (function-locals funct))
  (indented (pretty-print-block (function-body funct)))
  (println/indent "∇"))

@ Each of these depends on printing out blocks, which we handle here.

@c () => ()
@<AST Pretty Printer@>=
(define (pretty-print-block blk)
  (assert (block? blk))
  (for-each pretty-print-statement
            (block-statements blk)))

@ There are three different forms of statements that we may have,
$Assignment$, $If$, and $While$ statements. There are all encapsulated
in the statement printer.

@c () => ()
@<AST Pretty Printer@>=
(define (pretty-print-statement stmt)
  (assert (statement? stmt))
  (cond
    [(assignment? stmt) (pretty-print-assignment stmt)]
    [(if? stmt) (pretty-print-if stmt)]
    [(while? stmt) (pretty-print-while stmt)]
    [else (error 'pretty-print-statement "unknown statement type" stmt)]))

@ The $Assignment$ statement type is a nice, simple, one line statement.

@c () => ()
@<AST Pretty Printer@>=
(define (pretty-print-assignment asgn)
  (assert (assignment? asgn))
  (println/indent "~a←~a"
    (variable-string (assignment-target asgn))
    (expression->string (assignment-value asgn))))

@ The $While$ statement is the next simplest to do, and it has the following
template:

\medskip\verbatim
:While <test>
  <block>
:EndWhile
!endverbatim\medskip

@c () => ()
@<AST Pretty Printer@>=
(define (pretty-print-while while)
  (assert (while? while))
  (println ":While ~a" (expression->string (while-test while)))
  (indented (pretty-print-block (while-body while)))
  (println ":EndWhile"))

@ The $If$ statement is one of the harder ones to pretty print.  The reason 
is that we want to capture the situation where we have an Else-If construct.
In order to do this, we have to check the alternative field.  We consider 
an $If$ construct to be an Else-If situation if there is only one 
statement in the alternative block and that statement is an $If$. In order 
to handle the Else If situation, we have an optional flag that tells us whether
or not we are printing an Else-If clause or a normal $If$ statement.

@c () => ()
@<AST Pretty Printer@>=
(define (alt-is-else-if? alt)
  (and (= 1 (length (block-statements)))
       (if? (car (block-statements)))))
(define pretty-print-if
  (case-lambda
    [(if-ast) (%pretty-print-if if-ast #f)]
    [(if-ast else-if?) (%pretty-print-if if-ast else-if?)]))
(define (%pretty-print-if if-ast else-if?)
  (assert (if? if-ast))
  (println/indent "~a ~a" 
    (if else-if? ":ElseIf" ":If")
    (expression-string (if-test if-ast)))
  (indented (pretty-print-block (if-consequent if-ast)))
  (if (alt-is-else-if? (if-alternative if-ast))
      (pretty-print-if (car (block-statements (if-alternative if-ast))) #t)
      (begin
        (println/indent ":Else")
        (indented (pretty-print-block (if-alternative if-ast)))
        (println/indent ":EndIf"))))

@ With all of the statement and block level operations done, we now turn to 
consider the sorts of pretty printing that does not imply a newline in the 
printing. This means expressions.  We have a different name for the pretty 
printer of expressions to distinguish it from the normal pretty printing 
functions, namely, |expression->string|.  For starters, we can split the 
printing into the $Array$ and $Application$ sub-types.

@c () => ()
@<AST Pretty Printer@>=
(define (expression->string exp)
  (assert (expression? exp))
  (cond
    [(array? exp) (array->string exp)]
    [(application? exp) (application->string exp)]
    [(reference? exp) (variable-string (reference-variable exp))]
    [else (error 'expression->string "unknown expression type" exp)]))

@ Likewise, we will separate the $Array$ case into three cases, one for 
each of the pure arrays and one for the mixed character and numeric arrays.

@c () => ()
@<AST Pretty Printer@>=
(define (array->string arr)
  (assert (array? arr))
  (cond
    [(num-array? arr) (num-array->string arr)]
    [(char-array? arr) (char-array->string arr)]
    [(mixed-array? arr) (mixed-array->string arr)]
    [else (error 'array->string "unknown array type" arr)]))

@ The pure arrays are simple to print because they have a single character 
type to deal with.

@c () => ()
@<AST Pretty Printer@>=
(define (num-array->string arr)
  (assert (num-array? arr)) 
  (format "~{~a~^ ~}" (array-elements arr)))
(define (char-array->string arr) 
  (assert (char-array? arr))
  (format "'~{~a~}'" (array-elements arr)))

@ The mixed array needs to print the numbers as normal but it needs to print 
the character parts in quotes.  To do this we will have two mutually recursive
procedures, the first for printing numbers and the second for printing characters.

@c () => ()
@<AST Pretty Printer@>=
(define (mixed-array->string arr)
  (define (numbers lst)
    (cond
      [(null? lst) '()]
      [(number? (car lst))
       (cons (number->string (car lst))
             (numbers (cdr lst)))]
      [(char? (car lst)) (characters '() lst)]
      [else (error 'mixed-array->string "unknown element type" (car lst))]))
  (define (conv res) (format "'~{~a~}'" (reverse res)))
  (define (characters res lst)
    (cond
      [(null? lst) (if (pair? res) (list (conv res)) '())]
      [(char? (car lst)) (characters (cons (car lst) res) (cdr lst))]
      [(number? (car lst)) (cons (conv res) (numbers lst))]
      [else (error 'mixed-array->string "unknown element type" (car lst))]))
  (assert (mixed-array? arr))
  (format "~{~a~^ ~}" (numbers (array-elements arr))))

@ We will divide up the task of pretty printing applications the same 
way that we do the arrays. Specifically, there are three classes of 
applications, the niladic, monadic, and dyadic forms. 

@c () => ()
@<AST Pretty Printer@>=
(define (application->string app)
  (assert (application? app))
  (cond
    [(niladic? app) (niladic->string app)]
    [(monadic? app) (monadic->string app)]
    [(dyadic? app) (dyadic->string app)]
    [eles (error 'application->string "unknown application type" app)]))

@ A niladic application is basically just a variable reference, which 
requires nothing more than rendering the variable.

@c () => ()
@<AST Pretty Printer@>=
(define (niladic->string nil) 
  (assert (niladic? nil)) 
  (variable-string (application-name nil)))

@ A monadic application has one additional consideration.  It must make sure 
not to put two identifiers together when they might be confused with one. 
To do this we implement a simple function to ask whether two strings can 
go right next to one another.

@c () => ()
@<AST Pretty Printer@>=
(define (needs-space? s1 s2)
  (and (< 0 (string-length s1)) (< 0 (string-length s2))
       (char-alphanumeric? (string-ref s1 (- (string-length s1) 1)))
       (char-alphanumeric? (string-ref s2 0))))

@ After this the monadic case becomes a simple matter of tacking on the name 
of the procedure to the single argument.

@c () => ()
@<AST Pretty Printer@>=
(define (monadic->string mon) 
  (assert (monadic? mon))
  (let ([vs (variable-string (application-name mon))]
        [es (expression->string (monadic-right mon))]) 
    (format "~a~a~a" vs (if (needs-space? vs es) " " "") es)))

@ The dyadic situation has the same considerations of the monadic pretty printer 
in addition to the consideration of order of evaluation.  That is, if we have a 
simple expression we do not need to wrap the left hand side in parentheses, but 
if we do not have a simple expression, the left hand side should be wrapped in 
parentheses to preserve the described order of evaluation.  We have a simple 
helper |simple-expression?| to help us out with this.  We consider a simple 
expression to be one that is either an array or a niladic application.

@c () => ()
@<AST Pretty Printer@>=
(define (simple-expression? exp) (or (array? exp) (niladic? exp)))
(define (dyadic->string dya) 
  (assert (dyadic? dya)) 
  (let ([ls (expression->string (dyadic-left dya))]
        [vs (variable-string (application-name dya))]
        [rs (expression->string (dyadic-right dya))])
    (format "~a~a~a~a~a"
      (if (simple-expression? (dyadic-left dya))
          ls
          (format "(~a)" ls))
      (if (needs-space? ls vs) " " "")
      vs
      (if (needs-space? vs rs) " " "")
      rs)))

@* 2 Example.  Here is a basic example of the constructor syntax used 
to produce a program that, ostensibly, prints the prime numbers up to 
some value.  One can use |pretty-print-ast| to pretty print this.

\medskip\verbatim
(:Essay "Compute Primes Using Outer Product"
  
"This program computes the primes of numbers up to a given number 
using the outer product.  This results in a quadratic time and space 
algorithm.  This program is designed to be an example HPAPL program, 
so we go a little overboard with some things since we want to show off 
most of the features.  Here is the actual computation."

(:SectionExp "Compute the primes up to X"
  (2 = +⌿ 0 = (⍳ X) ∘.\x7C; ⍳ X) / ⍳ X)
  
"We define a function PRIMES that will actually do the computation, 
even though it just calls out to the section."

(∇ (R ← PRIMES X) ()
  (← R (2 = +⌿ 0 = (⍳ X) ∘.\x7C; ⍳ X) / ⍳ X))

"Now we actually get the X that we are going to use from the user 
and we print back out the primes."

(:Program
  (← N ⎕)
  (← ⎕ PRIMES N))
)
!endverbatim\medskip

@* Rendering the code to C.  Now that the syntax and visualization 
of the program has been fully defined in the previous sections, it 
comes time to talk about how we actually convert this syntax into 
something that can be executed on a machine.  In our case, we are not 
going to compile directly to the machine language.  Instead, we will 
rely on another compiler, namely, the C compiler on the system, to do 
this work for us.  Moreover, to handle the parallel work, we will be 
assuming that our C compiler is actually a UPC compiler.  

The overall goal of the compiler is to work towards transforming an 
HPAPL program into one that is semantically close enought to a C 
program that we can easily do a syntactic transformation on it to get a 
C program out of it. To do this, we need to know what constitutes a 
proper subset of our syntax that can be translated into C.

@ We say that an HPAPL program is C-compatible if the following 
conditions hold:

\item{1)} There are no sections and no prose components;
\item{2)} There is only a single $Program$ section;
\item{3)} All expressions are of the form of scalar functions applied
  to scalar variables; or,
\item{4)} Any application of an user-defined function appears as a 
  single expression on the right hand side of an assignment;
\item{5)} All assignments are either of the form of \#4, or an assignment 
  to a scalar variable; or,
\item{6)} The assignment is of the shape |(I⌷X)←E| where |I| is a 
  scalar numeric variable expected to be a natural number, 
  |X| is some array, and |E| is an expression of the form of \#3;
\item{7)} There should be literal arrays in any user-defined functions, 
  except for scalars that appear as part of expressions in \#3 or 
  as the |I| value in \#6;
\item{8)} All literal arrays must appear as the sole expression of 
  an assignment to a single variable in the $Program$ part of the 
  code;
\item{9)} 

@ Assuming that we have the above guarantees, it is fairly straightforward 
to take that syntax tree and convert it to a C syntax.  This will be 
done in a few stages, which are themselves like effectful passes that 
do not change the AST any. 

@c () => (render-c/compat-ast)
@<Core code renderer@>=
(define (render-c/compat-ast ofile ast)
  (define op (open-input-file ofile 'replace))
  (format op "#include \"hpapl.h\"~n~n")
  @<Declare global variables@>
  @<Render the functions@>
  @<Render the $Program$@>
  (close-port op))

@ The first step in writing out the C file after the header elements 
are taken care of is the need to define all of the global variables 
globally in such a way that all of the functions will see it.  
These will all be arrays and they will be taken from the $Program$ 
part of the code, where the set of variables that are assigned at the 
top-level forms the set of globals.

@c (op ast)
@<Declare global variables@>=
(define prog (program-body (car (filter program? (essay-sections ast)))))
(define globals 
  (let get-globals ([stmts (block-statements prog)])
    (cond
      [(null? stmts) '()]
      [(assignment? (car stmts)) 
       (set-cons variable=? 
         (assignment-target (car stmts))
         (get-globals (cdr stmts)))]
      [(if? (car stmts)) 
       (get-globals
         (append (block-statements (if-consequent (car stmts)))
                 (block-statements (if-alternative (car stmts)))
                 (cdr stmts)))]
      [(while? (car stmts)) 
       (get-globals (append (while-body (car stmts)) (cdr stmts)))]
      [else (error #f "unknown statement type" (car stmts))])))
(format op "Array ~{*~a~^, ~};~n" (map variable-string globals))

@ In the above code, and elsewhere, it is useful to be able to talk 
about sets of objects.  We define a constructor for sets here.

@c () => (set-cons)
@<Helper Utilities@>=
(define set-cons
  (case-lambda
    [(eq? e set)
     (if (memp (lambda (x) (eq? e x)) set)
         set
         (cons e set))]
    [(e set) (if (memq e set) set (cons e set))]))

@ We will now consider rendering the main program entry point, which 
is a little simpler than rendering an arbitrary function. In the main 
program we have only a block of code to render.

@c (op ast)
@<Render the $Program$@>=
(define prog (program-body (car (filter program? (essay-sections ast)))))
(format op "int~nmain(int argc, char *argv[])~n{~n")
(render-block op prog)
(format op "\treturn 0;~n}~n")

@ Rendering the functions is just a matter of doing something similar 
to the above for each of the functions.

@c (op ast)
@<Render the functions@>=
(for-each
  (lambda (func)
    @<Render the signature of function |func|@>
    @<Render the locals of function |func|@>
    (render-block op (function-body func))
    (format op "}~n~n"))
  (filter function? (essay-sections ast)))

@ Rendering a function signature should give us one of these 
cases:

\medskip\verbatim
void funct(void);
void funct(Array *right);
void funct(Array *left, Array *right);
Array *funct(void);
Array *funct(Array *right);
Array *funct(Array *left, Array *right);
!endverbatim\medskip

@c (op func)
@<Render the signature of function |func|@>=
(define-values (name ret lft rgt)
  (values (variable-string (function-name func))
    (function-return func) (function-left func) (function-right func)))
(format op "~a" (if ret "Array *" "void "))
(format op "~a(" name) ;)
(if rgt
    (if lft ;((
        (format op "Array *~a, Array *~a) {~n"
                (variable-string lft) (variable-string rgt))
        (format op "Array *~a) {~n" (variable-string rgt))) ;(
    (format op "void) {~n"))))

@ When we render the locals of a function, we might usually assume 
that they are all arrays, but this is not necessarily the case if we 
have added new scalar variables through one of our passes.  If the 
variables are not scalar, then we want to declare them as arrays, 
and otherwise we declare them as |Scalar| types. 

@c (op func)
@<Render the locals of function |func|@>=
(define-values (scalar array) (split scalar? (function-locals func)))
(format op "Scalar ~{~a~^, ~};~n" (map variable-string scalar))
(format op "Array *~{~a~^, ~};~n" (map variable-string array)) 

@ The |split| function above is one of our utilities.

@c () => (split)
@<Helper Utilities@>=
(define (split pred? lst)
  (let-loop ([yes '()] [no '()] [lst lst])
    (cond
      [(null? lst) (values (reverse yes) (reverse no))]
      [(pred? (car lst)) (loop (cons (car lst) yes) no (cdr lst))]
      [else (loop yes (cons (car lst) no) (cdr lst))])))



@* Compilation cycle.

@* Defining rewrites.

@* Default compiler rewrites.

@* Index.
